using Microsoft.CodeAnalysis;
using System;
using System.Collections.Generic;
using System.Text;

namespace Soenneker.Gen.Reflection.Emitters;

/// <summary>
/// Emits extension methods for GetTypeGen calls
/// </summary>
internal static class ExtensionsEmitter
{
    /// <summary>
    /// Emits extension methods file for all collected types
    /// </summary>
    public static void EmitExtensionsFile(SourceProductionContext context, HashSet<ITypeSymbol> generatedTypes)
    {
        try
        {
            var sb = new StringBuilder();

            sb.AppendLine("// <auto-generated />");
            sb.AppendLine("using System;");
            sb.AppendLine("using System.Collections.Generic;");
            sb.AppendLine("using Soenneker.Gen.Reflection;");
            sb.AppendLine();
            sb.AppendLine("namespace Soenneker.Gen.Reflection");
            sb.AppendLine("{");
            sb.AppendLine();

            sb.AppendLine("/// <summary>");
            sb.AppendLine("/// Generated extension method replacements for GetTypeGen calls");
            sb.AppendLine("/// </summary>");
            sb.AppendLine("public static partial class TypeGenExtensions");
            sb.AppendLine("{");

            foreach (ITypeSymbol? typeSymbol in generatedTypes)
            {
                if (typeSymbol == null) continue;
                
                string typeName = typeSymbol.ToDisplayString();
                
                // Generate instance method replacement using optimized constructor
                sb.AppendLine($"    /// <summary>");
                sb.AppendLine($"    /// Generated GetTypeGen for {typeName}");
                sb.AppendLine($"    /// </summary>");
                sb.AppendLine($"    public static TypeInfoGen GetTypeGen(this {typeName} obj)");
                sb.AppendLine($"    {{");
                
                // For array types, use empty arrays instead of trying to access non-existent TypeInfoGen properties
                if (typeSymbol is IArrayTypeSymbol)
                {
                    sb.AppendLine($"        return new TypeInfoGen(\"{Emitter.GetTypeName(typeSymbol)}\", \"{typeSymbol.ToDisplayString()}\", \"{typeSymbol.ToDisplayString()}, {typeSymbol.ContainingAssembly?.Name ?? "Unknown"}\", {typeSymbol.IsValueType.ToString().ToLower()}, {typeSymbol.IsReferenceType.ToString().ToLower()}, {(typeSymbol is INamedTypeSymbol namedType && namedType.IsGenericType).ToString().ToLower()}, {Emitter.IsNullableType(typeSymbol).ToString().ToLower()}, Array.Empty<FieldInfoGen>(), Array.Empty<PropertyInfoGen>(), Array.Empty<MethodInfoGen>(), {Emitter.GetUnderlyingTypeName(typeSymbol)}, {Emitter.GetGenericTypeArgumentNames(typeSymbol)});");
                }
                else
                {
                    string className = Emitter.SanitizeTypeName(typeSymbol.ToDisplayString());
                    sb.AppendLine($"        return new TypeInfoGen(\"{Emitter.GetTypeName(typeSymbol)}\", \"{typeSymbol.ToDisplayString()}\", \"{typeSymbol.ToDisplayString()}, {typeSymbol.ContainingAssembly?.Name ?? "Unknown"}\", {typeSymbol.IsValueType.ToString().ToLower()}, {typeSymbol.IsReferenceType.ToString().ToLower()}, {(typeSymbol is INamedTypeSymbol namedType && namedType.IsGenericType).ToString().ToLower()}, {Emitter.IsNullableType(typeSymbol).ToString().ToLower()}, {className}TypeInfoGen.Fields, {className}TypeInfoGen.Properties, {className}TypeInfoGen.Methods, {Emitter.GetUnderlyingTypeName(typeSymbol)}, {Emitter.GetGenericTypeArgumentNames(typeSymbol)});");
                }
                
                sb.AppendLine($"    }}");
                sb.AppendLine();
            }
            
            sb.AppendLine("}");
            sb.AppendLine();
            sb.AppendLine("}");
            
            Emitter.AddSource(context, "TypeGenExtensions.g.cs", sb);
        }
        catch (Exception ex)
        {
            // Create a minimal file even if there's an error
            var sb = new StringBuilder();
            sb.AppendLine("// <auto-generated />");
            sb.AppendLine("using System;");
            sb.AppendLine("using Soenneker.Gen.Reflection;");
            sb.AppendLine();
            sb.AppendLine("namespace Soenneker.Gen.Reflection");
            sb.AppendLine("{");
            sb.AppendLine("public static partial class TypeGenExtensions");
            sb.AppendLine("{");
            sb.AppendLine("    // Error generating extension methods");
            sb.AppendLine("}");
            sb.AppendLine("}");
            Emitter.AddSource(context, "TypeGenExtensions.g.cs", sb);
        }
    }
}
