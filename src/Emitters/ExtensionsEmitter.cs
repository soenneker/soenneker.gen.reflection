using Microsoft.CodeAnalysis;
using System;
using System.Collections.Generic;
using System.Text;
using System.Runtime.CompilerServices;

namespace Soenneker.Gen.Reflection.Emitters;

/// <summary>
/// Emits optimized extension methods for GetTypeGen calls with .NET 9 optimizations
/// </summary>
internal static class ExtensionsEmitter
{
    /// <summary>
    /// Emits optimized extension methods file for all collected types
    /// </summary>
    public static void EmitExtensionsFile(SourceProductionContext context, HashSet<ITypeSymbol> generatedTypes)
    {
        try
        {
            var sb = new StringBuilder();

            sb.AppendLine("// <auto-generated />");
            sb.AppendLine("using System;");
            sb.AppendLine("using System.Collections.Generic;");
            sb.AppendLine("using System.Runtime.CompilerServices;");
            sb.AppendLine();
            sb.AppendLine("namespace Soenneker.Gen.Reflection");
            sb.AppendLine("{");
            sb.AppendLine();

            sb.AppendLine("/// <summary>");
            sb.AppendLine("/// Optimized extension method replacements for GetTypeGen calls");
            sb.AppendLine("/// </summary>");
            sb.AppendLine("public static partial class TypeGenExtensions");
            sb.AppendLine("{");

            // Generate cached TypeInfoGen instances first
            foreach (ITypeSymbol? typeSymbol in generatedTypes)
            {
                if (typeSymbol == null) continue;
                
                string typeName = typeSymbol.ToDisplayString();
                string className = Emitter.SanitizeTypeName(typeSymbol.ToDisplayString());
                
                // Generate cached static readonly field
                sb.AppendLine($"    /// <summary>");
                sb.AppendLine($"    /// Cached TypeInfoGen instance for {typeName}");
                sb.AppendLine($"    /// </summary>");
                sb.AppendLine($"    private static readonly TypeInfoGen _{className}TypeInfo = ");
                sb.AppendLine($"        new TypeInfoGen(\"{Emitter.GetTypeName(typeSymbol)}\", \"{typeSymbol.ToDisplayString()}\", \"{typeSymbol.ToDisplayString()}, {typeSymbol.ContainingAssembly?.Name ?? "Unknown"}\", {typeSymbol.IsValueType.ToString().ToLower()}, {typeSymbol.IsReferenceType.ToString().ToLower()}, {(typeSymbol is INamedTypeSymbol namedType && namedType.IsGenericType).ToString().ToLower()}, {Emitter.IsNullableType(typeSymbol).ToString().ToLower()}, ");
                
                // For array types, use empty arrays
                if (typeSymbol is IArrayTypeSymbol)
                {
                    sb.AppendLine($"            Array.Empty<FieldInfoGen>(), Array.Empty<PropertyInfoGen>(), Array.Empty<MethodInfoGen>(), {Emitter.GetUnderlyingTypeName(typeSymbol)}, {Emitter.GetGenericTypeArgumentNames(typeSymbol)});");
                }
                else
                {
                    sb.AppendLine($"            {className}TypeInfoGen.Fields, {className}TypeInfoGen.Properties, {className}TypeInfoGen.Methods, {Emitter.GetUnderlyingTypeName(typeSymbol)}, {Emitter.GetGenericTypeArgumentNames(typeSymbol)});");
                }
                sb.AppendLine();
            }
            
            // Generate GetTypeGen extension methods that return cached instances
            foreach (ITypeSymbol? typeSymbol in generatedTypes)
            {
                if (typeSymbol == null) continue;
                
                string typeName = typeSymbol.ToDisplayString();
                string className = Emitter.SanitizeTypeName(typeSymbol.ToDisplayString());
                
                // Generate instance method replacement that returns cached instance
                sb.AppendLine($"    /// <summary>");
                sb.AppendLine($"    /// Optimized GetTypeGen for {typeName}");
                sb.AppendLine($"    /// </summary>");
                sb.AppendLine($"    [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]");
                sb.AppendLine($"    public static TypeInfoGen GetTypeGen(this {typeName} obj)");
                sb.AppendLine($"    {{");
                sb.AppendLine($"        return _{className}TypeInfo;");
                sb.AppendLine($"    }}");
                sb.AppendLine();
            }
            
            sb.AppendLine("}");
            sb.AppendLine();
            sb.AppendLine("}");
            
            Emitter.AddSource(context, "TypeGenExtensions.g.cs", sb);
        }
        catch (Exception)
        {
            // Create a minimal file even if there's an error
            var sb = new StringBuilder();
            sb.AppendLine("// <auto-generated />");
            sb.AppendLine("using System;");
            sb.AppendLine("using System.Runtime.CompilerServices;");
            sb.AppendLine();
            sb.AppendLine("namespace Soenneker.Gen.Reflection");
            sb.AppendLine("{");
            sb.AppendLine("public static partial class TypeGenExtensions");
            sb.AppendLine("{");
            sb.AppendLine("    // Error generating extension methods");
            sb.AppendLine("}");
            sb.AppendLine("}");
            Emitter.AddSource(context, "TypeGenExtensions.g.cs", sb);
        }
    }
}
