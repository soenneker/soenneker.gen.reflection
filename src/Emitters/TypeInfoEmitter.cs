using Microsoft.CodeAnalysis;
using System;
using System.Linq;
using System.Text;

namespace Soenneker.Gen.Reflection.Emitters;

/// <summary>
/// Emits individual type info classes for each discovered type
/// </summary>
internal static class TypeInfoEmitter
{
    /// <summary>
    /// Emits a type info class for a specific type symbol
    /// </summary>
    public static void EmitTypeInfoGenFile(SourceProductionContext context, ITypeSymbol typeSymbol)
    {
        try
        {
            var sb = new StringBuilder();
            var fileName = $"{Emitter.SanitizeTypeName(typeSymbol.ToDisplayString())}TypeInfoGen.g.cs";

            // Trace generated type for debugging
            context.ReportDiagnostic(Diagnostic.Create(new DiagnosticDescriptor("SGR101", "Generating TypeInfoGen", $"Generating TypeInfoGen for {typeSymbol.ToDisplayString()}", "GetTypeGen", DiagnosticSeverity.Info, true), Location.None));

            sb.AppendLine("// <auto-generated />");
            sb.AppendLine("using System;");
            sb.AppendLine("using System.Collections.Generic;");
            sb.AppendLine();
            sb.AppendLine("namespace Soenneker.Gen.Reflection");
            sb.AppendLine("{");
            sb.AppendLine();
            
            try
            {
                EmitTypeInfoGenClass(sb, typeSymbol);
            }
            catch (Exception ex)
            {
                context.ReportDiagnostic(Diagnostic.Create(
                    new DiagnosticDescriptor("SGR011", "TypeInfoGen Class Generation Error", 
                        $"Error generating TypeInfoGen class for {typeSymbol.ToDisplayString()}: {ex}", 
                        "GetTypeGen", DiagnosticSeverity.Error, true), Location.None));
                throw;
            }
            
            sb.AppendLine("}");
            Emitter.AddSource(context, fileName, sb);
        }
        catch (Exception ex)
        {
            context.ReportDiagnostic(Diagnostic.Create(
                new DiagnosticDescriptor("SGR010", "TypeInfoGen File Generation Error", 
                    $"Error generating TypeInfoGen file for {typeSymbol.ToDisplayString()}: {ex}", 
                    "GetTypeGen", DiagnosticSeverity.Error, true), Location.None));
        }
    }

    private static void EmitTypeInfoGenClass(StringBuilder sb, ITypeSymbol typeSymbol)
    {
        string typeName = typeSymbol.ToDisplayString();
        string className = Emitter.SanitizeTypeName(typeName);
        
        sb.AppendLine($"/// <summary>");
        sb.AppendLine($"/// Generated type information for {typeName}");
        sb.AppendLine($"/// </summary>");
        sb.AppendLine($"public static partial class {className}TypeInfoGen");
        sb.AppendLine($"{{");
        sb.AppendLine($"    /// <summary>");
        sb.AppendLine($"    /// Gets the type name for {typeName}");
        sb.AppendLine($"    /// </summary>");
        sb.AppendLine($"    public static string Name => \"{Emitter.GetTypeName(typeSymbol)}\";");
        sb.AppendLine();
        sb.AppendLine($"    /// <summary>");
        sb.AppendLine($"    /// Gets the full type name for {typeName}");
        sb.AppendLine($"    /// </summary>");
        sb.AppendLine($"    public static string FullName => \"{typeSymbol.ToDisplayString()}\";");
        sb.AppendLine();
        sb.AppendLine($"    /// <summary>");
        sb.AppendLine($"    /// Gets the assembly qualified name for {typeName}");
        sb.AppendLine($"    /// </summary>");
        sb.AppendLine($"    public static string AssemblyQualifiedName => \"{typeSymbol.ToDisplayString()}, {typeSymbol.ContainingAssembly?.Name ?? "Unknown"}\";");
        sb.AppendLine();
        sb.AppendLine($"    /// <summary>");
        sb.AppendLine($"    /// Gets whether {typeName} is a value type");
        sb.AppendLine($"    /// </summary>");
        sb.AppendLine($"    public static bool IsValueType => {typeSymbol.IsValueType.ToString().ToLower()};");
        sb.AppendLine();
        sb.AppendLine($"    /// <summary>");
        sb.AppendLine($"    /// Gets whether {typeName} is a reference type");
        sb.AppendLine($"    /// </summary>");
        sb.AppendLine($"    public static bool IsReferenceType => {typeSymbol.IsReferenceType.ToString().ToLower()};");
        sb.AppendLine();
        sb.AppendLine($"    /// <summary>");
        sb.AppendLine($"    /// Gets whether {typeName} is generic");
        sb.AppendLine($"    /// </summary>");
        sb.AppendLine($"    public static bool IsGenericType => {(typeSymbol is INamedTypeSymbol namedType && namedType.IsGenericType).ToString().ToLower()};");
        sb.AppendLine();
        sb.AppendLine($"    /// <summary>");
        sb.AppendLine($"    /// Gets whether {typeName} is nullable");
        sb.AppendLine($"    /// </summary>");
        sb.AppendLine($"    public static bool IsNullable => {Emitter.IsNullableType(typeSymbol).ToString().ToLower()};");
        sb.AppendLine();
        
        // For array types, use empty arrays instead of trying to generate field/property/method information
        if (typeSymbol is IArrayTypeSymbol)
        {
            sb.AppendLine($"    /// <summary>");
            sb.AppendLine($"    /// Gets all fields of the type (empty for arrays)");
            sb.AppendLine($"    /// </summary>");
            sb.AppendLine($"    public static FieldInfoGen[] Fields => Array.Empty<FieldInfoGen>();");
            sb.AppendLine();
            sb.AppendLine($"    /// <summary>");
            sb.AppendLine($"    /// Gets all properties of the type (empty for arrays)");
            sb.AppendLine($"    /// </summary>");
            sb.AppendLine($"    public static PropertyInfoGen[] Properties => Array.Empty<PropertyInfoGen>();");
            sb.AppendLine();
            sb.AppendLine($"    /// <summary>");
            sb.AppendLine($"    /// Gets all methods of the type (empty for arrays)");
            sb.AppendLine($"    /// </summary>");
            sb.AppendLine($"    public static MethodInfoGen[] Methods => Array.Empty<MethodInfoGen>();");
        }
        else
        {
            // Generate optimized field information using Roslyn introspection
            EmitFieldInformation(sb, typeSymbol);
            
            // Generate optimized property information using Roslyn introspection
            EmitPropertyInformation(sb, typeSymbol);
            
            // Generate optimized method information using Roslyn introspection
            EmitMethodInformation(sb, typeSymbol);
        }
        
        sb.AppendLine($"}}");
        sb.AppendLine();
    }

    private static void EmitFieldInformation(StringBuilder sb, ITypeSymbol typeSymbol)
    {
        IFieldSymbol[] allInstanceFields = typeSymbol.GetMembers().OfType<IFieldSymbol>()
            .Where(f => !f.IsImplicitlyDeclared && f.AssociatedSymbol == null && !f.IsStatic)
            .ToArray();
        
        sb.AppendLine($"    /// <summary>");
        sb.AppendLine($"    /// Gets all fields of the type");
        sb.AppendLine($"    /// </summary>");
        sb.AppendLine($"    public static FieldInfoGen[] Fields => new FieldInfoGen[]");
        sb.AppendLine($"    {{");
        
        foreach (IFieldSymbol field in allInstanceFields)
        {
            string fieldType = Emitter.GetTypeName(field.Type);
            if (field.DeclaredAccessibility == Accessibility.Public)
            {
                string declaringType = Emitter.FormatFullyQualified(typeSymbol);
                string castType = Emitter.FormatFullyQualified(field.Type);
                var getter = $"new Func<object, object>(obj => (({declaringType})obj).{field.Name})";
                string setter = field.IsReadOnly ? "null" : $"new Action<object, object>((obj, value) => (({declaringType})obj).{field.Name} = ({castType})value)";
                sb.AppendLine($"        new FieldInfoGen(\"{field.Name}\", \"{fieldType}\", {field.IsReadOnly.ToString().ToLower()}, {getter}, {setter}),");
            }
            else
            {
                // Metadata only for non-public fields to avoid accessibility errors
                sb.AppendLine($"        new FieldInfoGen(\"{field.Name}\", \"{fieldType}\", {field.IsReadOnly.ToString().ToLower()}),");
            }
        }
        
        sb.AppendLine($"    }};");
        sb.AppendLine();
    }

    private static void EmitPropertyInformation(StringBuilder sb, ITypeSymbol typeSymbol)
    {
        IPropertySymbol[] properties = typeSymbol.GetMembers().OfType<IPropertySymbol>()
            .Where(p => !p.IsIndexer && p.Parameters.Length == 0 && p.ExplicitInterfaceImplementations.Length == 0 && p.CanBeReferencedByName && !p.IsStatic)
            .ToArray();
        
        sb.AppendLine($"    /// <summary>");
        sb.AppendLine($"    /// Gets all properties of the type");
        sb.AppendLine($"    /// </summary>");
        sb.AppendLine($"    public static PropertyInfoGen[] Properties => new PropertyInfoGen[]");
        sb.AppendLine($"    {{");
        
        foreach (IPropertySymbol property in properties)
        {
            string declaringType = Emitter.FormatFullyQualified(typeSymbol);
            string propTypeName = Emitter.GetTypeName(property.Type);
            string castType = Emitter.FormatFullyQualified(property.Type);
            string getter = property.GetMethod != null ? $"new Func<object, object>(obj => (({declaringType})obj).{property.Name})" : "null";
            string setter = property.SetMethod != null ? $"new Action<object, object>((obj, value) => (({declaringType})obj).{property.Name} = ({castType})value)" : "null";
            // Provide a richer TypeInfoGen for property type to allow IsGenericType checks
            sb.AppendLine($"        new PropertyInfoGen(\"{property.Name}\", new TypeInfoGen(\"{propTypeName}\", \"{property.Type.ToDisplayString()}\", \"{property.Type.ToDisplayString()}, {property.ContainingType.ContainingAssembly.Name}\", {property.Type.IsValueType.ToString().ToLower()}, {property.Type.IsReferenceType.ToString().ToLower()}, {(property.Type is INamedTypeSymbol pNamed && pNamed.IsGenericType).ToString().ToLower()}, {Emitter.IsNullableType(property.Type).ToString().ToLower()}, Array.Empty<FieldInfoGen>(), Array.Empty<PropertyInfoGen>(), Array.Empty<MethodInfoGen>(), {Emitter.GetUnderlyingTypeName(property.Type)}, {Emitter.GetGenericTypeArgumentNames(property.Type)}), { (property.GetMethod != null).ToString().ToLower() }, { (property.SetMethod != null).ToString().ToLower() }, {getter}, {setter}),");
        }
        
        sb.AppendLine($"    }};");
        sb.AppendLine();
    }

    private static void EmitMethodInformation(StringBuilder sb, ITypeSymbol typeSymbol)
    {
        IMethodSymbol[] methods = typeSymbol.GetMembers().OfType<IMethodSymbol>().Where(m => m.MethodKind == MethodKind.Ordinary).ToArray();
        
        sb.AppendLine($"    /// <summary>");
        sb.AppendLine($"    /// Gets all methods of the type");
        sb.AppendLine($"    /// </summary>");
        sb.AppendLine($"    public static MethodInfoGen[] Methods => new MethodInfoGen[]");
        sb.AppendLine($"    {{");
        
        foreach (IMethodSymbol method in methods)
        {
            sb.AppendLine($"        new MethodInfoGen(\"{method.Name}\", \"{Emitter.GetTypeName(method.ReturnType)}\", {method.IsStatic.ToString().ToLower()}),");
        }
        
        sb.AppendLine($"    }};");
        sb.AppendLine();
    }
}
