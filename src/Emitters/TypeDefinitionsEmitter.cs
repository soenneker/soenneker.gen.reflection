using Microsoft.CodeAnalysis;
using System.Text;

namespace Soenneker.Gen.Reflection.Emitters;

/// <summary>
/// Emits the base type definitions (TypeInfoGen, FieldInfoGen, PropertyInfoGen, MethodInfoGen)
/// </summary>
internal static class TypeDefinitionsEmitter
{
    /// <summary>
    /// Emits the type definitions file containing all the base structs
    /// </summary>
    public static void Emit(SourceProductionContext context)
    {
        var sb = new StringBuilder();
        
        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("#nullable enable");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.Linq;");
        sb.AppendLine("using System.Runtime.CompilerServices;");
        sb.AppendLine();
        sb.AppendLine("namespace Soenneker.Gen.Reflection");
        sb.AppendLine("{");
        sb.AppendLine();
        
        EmitTypeInfoGen(sb);
        EmitFieldInfoGen(sb);
        EmitPropertyInfoGen(sb);
        EmitMethodInfoGen(sb);
        
        sb.AppendLine("}");
        sb.AppendLine();
        sb.AppendLine("namespace Soenneker.Gen.Reflection.Registries");
        sb.AppendLine("{");
        EmitRegistries(sb);
        sb.AppendLine("}");

        Emitter.AddSource(context, "TypeDefinitions.g.cs", sb);
    }

    private static void EmitTypeInfoGen(StringBuilder sb)
    {
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Represents type information at compile time");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    public readonly struct TypeInfoGen");
        sb.AppendLine("    {");
        sb.AppendLine("        private readonly string _name;");
        sb.AppendLine("        private readonly string _fullName;");
        sb.AppendLine("        private readonly string _assemblyQualifiedName;");
        sb.AppendLine("        private readonly bool _isValueType;");
        sb.AppendLine("        private readonly bool _isReferenceType;");
        sb.AppendLine("        private readonly bool _isGenericType;");
        sb.AppendLine("        private readonly bool _isNullable;");
        sb.AppendLine("        private readonly FieldInfoGen[] _fields;");
        sb.AppendLine("        private readonly PropertyInfoGen[] _properties;");
        sb.AppendLine("        private readonly MethodInfoGen[] _methods;");
        sb.AppendLine("        private readonly string? _underlyingTypeName;");
        sb.AppendLine("        private readonly string[]? _genericTypeArgumentNames;");
        sb.AppendLine();
        sb.AppendLine("        public TypeInfoGen(string name, string fullName, string assemblyQualifiedName, bool isValueType, bool isReferenceType, bool isGenericType, bool isNullable, FieldInfoGen[] fields, PropertyInfoGen[] properties, MethodInfoGen[] methods, string? underlyingTypeName, string[]? genericTypeArgumentNames)");
        sb.AppendLine("        {");
        sb.AppendLine("            _name = name;");
        sb.AppendLine("            _fullName = fullName;");
        sb.AppendLine("            _assemblyQualifiedName = assemblyQualifiedName;");
        sb.AppendLine("            _isValueType = isValueType;");
        sb.AppendLine("            _isReferenceType = isReferenceType;");
        sb.AppendLine("            _isGenericType = isGenericType;");
        sb.AppendLine("            _isNullable = isNullable;");
        sb.AppendLine("            _fields = fields;");
        sb.AppendLine("            _properties = properties;");
        sb.AppendLine("            _methods = methods;");
        sb.AppendLine("            _underlyingTypeName = underlyingTypeName;");
        sb.AppendLine("            _genericTypeArgumentNames = genericTypeArgumentNames;");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        public string Name => _name;");
        sb.AppendLine("        public string FullName => _fullName;");
        sb.AppendLine("        public string AssemblyQualifiedName => _assemblyQualifiedName;");
        sb.AppendLine("        public bool IsValueType => _isValueType;");
        sb.AppendLine("        public bool IsReferenceType => _isReferenceType;");
        sb.AppendLine("        public bool IsGenericType => _isGenericType;");
        sb.AppendLine("        public bool IsNullable => _isNullable;");
        sb.AppendLine("        public FieldInfoGen[] Fields => _fields;");
        sb.AppendLine("        public PropertyInfoGen[] Properties => _properties;");
        sb.AppendLine("        public MethodInfoGen[] Methods => _methods;");
        sb.AppendLine("        public string? UnderlyingTypeName => _underlyingTypeName;");
        sb.AppendLine("        public string[]? GenericTypeArgumentNames => _genericTypeArgumentNames;");
        sb.AppendLine();
        sb.AppendLine("        // Additional properties for compatibility");
        sb.AppendLine("        public TypeInfoGen? UnderlyingType => _underlyingTypeName != null ? new TypeInfoGen(_underlyingTypeName, _underlyingTypeName, _underlyingTypeName, false, true, false, false, Array.Empty<FieldInfoGen>(), Array.Empty<PropertyInfoGen>(), Array.Empty<MethodInfoGen>(), null, null) : null;");
        sb.AppendLine("        public TypeInfoGen[] GenericTypeArguments => _genericTypeArgumentNames?.Select(name => new TypeInfoGen(name, name, name, false, true, false, false, Array.Empty<FieldInfoGen>(), Array.Empty<PropertyInfoGen>(), Array.Empty<MethodInfoGen>(), null, null)).ToArray() ?? Array.Empty<TypeInfoGen>();");
        sb.AppendLine();
        sb.AppendLine("        // Helper methods");
        sb.AppendLine("        public PropertyInfoGen? GetProperty(string name) => Array.Find(_properties, p => p.Name == name);");
        sb.AppendLine("        public FieldInfoGen? GetField(string name) => Array.Find(_fields, f => f.Name == name);");
        sb.AppendLine("        public MethodInfoGen? GetMethod(string name) => Array.Find(_methods, m => m.Name == name);");
        sb.AppendLine("    }");
        sb.AppendLine();
    }

    private static void EmitFieldInfoGen(StringBuilder sb)
    {
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Represents field information at compile time");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    public readonly struct FieldInfoGen");
        sb.AppendLine("    {");
        sb.AppendLine("        private readonly string _name;");
        sb.AppendLine("        private readonly string _fieldType;");
        sb.AppendLine("        private readonly bool _isReadOnly;");
        sb.AppendLine("        private readonly object? _getter;");
        sb.AppendLine("        private readonly object? _setter;");
        sb.AppendLine();
        sb.AppendLine("        public FieldInfoGen(string name, string fieldType, bool isReadOnly, object? getter = null, object? setter = null)");
        sb.AppendLine("        {");
        sb.AppendLine("            _name = name;");
        sb.AppendLine("            _fieldType = fieldType;");
        sb.AppendLine("            _isReadOnly = isReadOnly;");
        sb.AppendLine("            _getter = getter;");
        sb.AppendLine("            _setter = setter;");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        public string Name => _name;");
        sb.AppendLine("        public TypeInfoGen FieldType => new TypeInfoGen(_fieldType, _fieldType, _fieldType, false, true, false, false, Array.Empty<FieldInfoGen>(), Array.Empty<PropertyInfoGen>(), Array.Empty<MethodInfoGen>(), null, null);");
        sb.AppendLine("        public bool IsReadOnly => _isReadOnly;");
        sb.AppendLine("        public object? Getter => _getter;");
        sb.AppendLine("        public object? Setter => _setter;");
        sb.AppendLine();
        sb.AppendLine("        public object? GetValue(object? obj)");
        sb.AppendLine("        {");
        sb.AppendLine("            if (_getter is Func<object, object> getterFunc)");
        sb.AppendLine("                return getterFunc(obj);");
        sb.AppendLine("            return null;");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        public void SetValue(object? obj, object? value)");
        sb.AppendLine("        {");
        sb.AppendLine("            if (_setter is Action<object, object> setterAction)");
        sb.AppendLine("                setterAction(obj, value);");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine();
    }

    private static void EmitPropertyInfoGen(StringBuilder sb)
    {
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Represents property information at compile time");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    public readonly struct PropertyInfoGen");
        sb.AppendLine("    {");
        sb.AppendLine("        private readonly string _name;");
        sb.AppendLine("        private readonly TypeInfoGen _propertyType;");
        sb.AppendLine("        private readonly bool _canRead;");
        sb.AppendLine("        private readonly bool _canWrite;");
        sb.AppendLine("        private readonly object? _getter;");
        sb.AppendLine("        private readonly object? _setter;");
        sb.AppendLine();
        sb.AppendLine("        public PropertyInfoGen(string name, TypeInfoGen propertyType, bool canRead, bool canWrite, object? getter = null, object? setter = null)");
        sb.AppendLine("        {");
        sb.AppendLine("            _name = name;");
        sb.AppendLine("            _propertyType = propertyType;");
        sb.AppendLine("            _canRead = canRead;");
        sb.AppendLine("            _canWrite = canWrite;");
        sb.AppendLine("            _getter = getter;");
        sb.AppendLine("            _setter = setter;");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        public string Name => _name;");
        sb.AppendLine("        public TypeInfoGen PropertyType => _propertyType;");
        sb.AppendLine("        public bool CanRead => _canRead;");
        sb.AppendLine("        public bool CanWrite => _canWrite;");
        sb.AppendLine("        public object? Getter => _getter;");
        sb.AppendLine("        public object? Setter => _setter;");
        sb.AppendLine();
        sb.AppendLine("        public object? GetValue(object? obj)");
        sb.AppendLine("        {");
        sb.AppendLine("            if (_getter is Func<object, object> getterFunc)");
        sb.AppendLine("                return getterFunc(obj);");
        sb.AppendLine("            return null;");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        public void SetValue(object? obj, object? value)");
        sb.AppendLine("        {");
        sb.AppendLine("            if (_setter is Action<object, object> setterAction)");
        sb.AppendLine("                setterAction(obj, value);");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine();
    }

    private static void EmitMethodInfoGen(StringBuilder sb)
    {
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Represents method information at compile time");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    public readonly struct MethodInfoGen");
        sb.AppendLine("    {");
        sb.AppendLine("        private readonly string _name;");
        sb.AppendLine("        private readonly string _returnType;");
        sb.AppendLine("        private readonly bool _isStatic;");
        sb.AppendLine("        private readonly string[]? _parameterTypes;");
        sb.AppendLine();
        sb.AppendLine("        public MethodInfoGen(string name, string returnType, bool isStatic)");
        sb.AppendLine("        {");
        sb.AppendLine("            _name = name;");
        sb.AppendLine("            _returnType = returnType;");
        sb.AppendLine("            _isStatic = isStatic;");
        sb.AppendLine("            _parameterTypes = Array.Empty<string>();");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        public MethodInfoGen(string name, string returnType, bool isStatic, string[] parameterTypes)");
        sb.AppendLine("        {");
        sb.AppendLine("            _name = name;");
        sb.AppendLine("            _returnType = returnType;");
        sb.AppendLine("            _isStatic = isStatic;");
        sb.AppendLine("            _parameterTypes = parameterTypes;");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        public string Name => _name;");
        sb.AppendLine("        public TypeInfoGen ReturnType => new TypeInfoGen(_returnType, _returnType, _returnType, false, true, false, false, Array.Empty<FieldInfoGen>(), Array.Empty<PropertyInfoGen>(), Array.Empty<MethodInfoGen>(), null, null);");
        sb.AppendLine("        public bool IsStatic => _isStatic;");
        sb.AppendLine("        public TypeInfoGen[] ParameterTypes => _parameterTypes == null || _parameterTypes.Length == 0 ? Array.Empty<TypeInfoGen>() : Array.ConvertAll(_parameterTypes, n => new TypeInfoGen(n, n, n, false, true, false, false, Array.Empty<FieldInfoGen>(), Array.Empty<PropertyInfoGen>(), Array.Empty<MethodInfoGen>(), null, null));");
        sb.AppendLine("    }");
        sb.AppendLine();
    }

    private static void EmitRegistries(StringBuilder sb)
    {
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Global registry for precomputed TypeInfoGen instances");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    public static class TypeRegistry");
        sb.AppendLine("    {");
        sb.AppendLine("        private static readonly System.Collections.Generic.Dictionary<ulong, Soenneker.Gen.Reflection.TypeInfoGen> _types = new();");
        sb.AppendLine("        private static readonly System.Collections.Generic.Dictionary<string, ulong> _nameToId = new();");
        sb.AppendLine("        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static void Register(ulong id, Soenneker.Gen.Reflection.TypeInfoGen typeInfo, string name) { _types[id] = typeInfo; _nameToId[name] = id; }");
        sb.AppendLine("        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Soenneker.Gen.Reflection.TypeInfoGen GetType(ulong id) => _types.TryGetValue(id, out var v) ? v : default;");
        sb.AppendLine("        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Soenneker.Gen.Reflection.TypeInfoGen? GetTypeByName(string name) => _nameToId.TryGetValue(name, out var id) ? GetType(id) : (Soenneker.Gen.Reflection.TypeInfoGen?)null;");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Global registry for precomputed FieldInfoGen instances");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    public static class FieldRegistry");
        sb.AppendLine("    {");
        sb.AppendLine("        private static readonly System.Collections.Generic.Dictionary<ulong, Soenneker.Gen.Reflection.FieldInfoGen> _fields = new();");
        sb.AppendLine("        private static readonly System.Collections.Generic.Dictionary<ulong, System.Collections.Generic.Dictionary<string, ulong>> _typeToFieldIds = new();");
        sb.AppendLine("        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static void Register(ulong id, Soenneker.Gen.Reflection.FieldInfoGen info, ulong typeId) { _fields[id] = info; if (!_typeToFieldIds.TryGetValue(typeId, out var map)) { map = new System.Collections.Generic.Dictionary<string, ulong>(); _typeToFieldIds[typeId] = map; } map[info.Name] = id; }");
        sb.AppendLine("        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Soenneker.Gen.Reflection.FieldInfoGen GetField(ulong id) => _fields.TryGetValue(id, out var v) ? v : default;");
        sb.AppendLine("        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Soenneker.Gen.Reflection.FieldInfoGen? GetFieldByName(ulong typeId, string name) => _typeToFieldIds.TryGetValue(typeId, out var map) && map.TryGetValue(name, out var id) ? GetField(id) : (Soenneker.Gen.Reflection.FieldInfoGen?)null;");
        sb.AppendLine("        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static ReadOnlySpan<Soenneker.Gen.Reflection.FieldInfoGen> GetFieldsForType(ulong typeId) { if (!_typeToFieldIds.TryGetValue(typeId, out var map)) return ReadOnlySpan<Soenneker.Gen.Reflection.FieldInfoGen>.Empty; var arr = new Soenneker.Gen.Reflection.FieldInfoGen[map.Count]; int i = 0; foreach (var id in map.Values) arr[i++] = GetField(id); return arr; }");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Global registry for precomputed PropertyInfoGen instances");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    public static class PropertyRegistry");
        sb.AppendLine("    {");
        sb.AppendLine("        private static readonly System.Collections.Generic.Dictionary<ulong, Soenneker.Gen.Reflection.PropertyInfoGen> _properties = new();");
        sb.AppendLine("        private static readonly System.Collections.Generic.Dictionary<ulong, System.Collections.Generic.Dictionary<string, ulong>> _typeToPropertyIds = new();");
        sb.AppendLine("        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static void Register(ulong id, Soenneker.Gen.Reflection.PropertyInfoGen info, ulong typeId) { _properties[id] = info; if (!_typeToPropertyIds.TryGetValue(typeId, out var map)) { map = new System.Collections.Generic.Dictionary<string, ulong>(); _typeToPropertyIds[typeId] = map; } map[info.Name] = id; }");
        sb.AppendLine("        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Soenneker.Gen.Reflection.PropertyInfoGen GetProperty(ulong id) => _properties.TryGetValue(id, out var v) ? v : default;");
        sb.AppendLine("        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Soenneker.Gen.Reflection.PropertyInfoGen? GetPropertyByName(ulong typeId, string name) => _typeToPropertyIds.TryGetValue(typeId, out var map) && map.TryGetValue(name, out var id) ? GetProperty(id) : (Soenneker.Gen.Reflection.PropertyInfoGen?)null;");
        sb.AppendLine("        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static ReadOnlySpan<Soenneker.Gen.Reflection.PropertyInfoGen> GetPropertiesForType(ulong typeId) { if (!_typeToPropertyIds.TryGetValue(typeId, out var map)) return ReadOnlySpan<Soenneker.Gen.Reflection.PropertyInfoGen>.Empty; var arr = new Soenneker.Gen.Reflection.PropertyInfoGen[map.Count]; int i = 0; foreach (var id in map.Values) arr[i++] = GetProperty(id); return arr; }");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Global registry for precomputed MethodInfoGen instances");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    public static class MethodRegistry");
        sb.AppendLine("    {");
        sb.AppendLine("        private static readonly System.Collections.Generic.Dictionary<ulong, Soenneker.Gen.Reflection.MethodInfoGen> _methods = new();");
        sb.AppendLine("        private static readonly System.Collections.Generic.Dictionary<ulong, System.Collections.Generic.Dictionary<string, ulong>> _typeToMethodIds = new();");
        sb.AppendLine("        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static void Register(ulong id, Soenneker.Gen.Reflection.MethodInfoGen info, ulong typeId) { _methods[id] = info; if (!_typeToMethodIds.TryGetValue(typeId, out var map)) { map = new System.Collections.Generic.Dictionary<string, ulong>(); _typeToMethodIds[typeId] = map; } map[info.Name] = id; }");
        sb.AppendLine("        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Soenneker.Gen.Reflection.MethodInfoGen GetMethod(ulong id) => _methods.TryGetValue(id, out var v) ? v : default;");
        sb.AppendLine("        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static Soenneker.Gen.Reflection.MethodInfoGen? GetMethodByName(ulong typeId, string name) => _typeToMethodIds.TryGetValue(typeId, out var map) && map.TryGetValue(name, out var id) ? GetMethod(id) : (Soenneker.Gen.Reflection.MethodInfoGen?)null;");
        sb.AppendLine("        [MethodImpl(MethodImplOptions.AggressiveInlining)] public static ReadOnlySpan<Soenneker.Gen.Reflection.MethodInfoGen> GetMethodsForType(ulong typeId) { if (!_typeToMethodIds.TryGetValue(typeId, out var map)) return ReadOnlySpan<Soenneker.Gen.Reflection.MethodInfoGen>.Empty; var arr = new Soenneker.Gen.Reflection.MethodInfoGen[map.Count]; int i = 0; foreach (var id in map.Values) arr[i++] = GetMethod(id); return arr; }");
        sb.AppendLine("    }");
    }
}
