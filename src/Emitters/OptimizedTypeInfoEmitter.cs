using Microsoft.CodeAnalysis;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Runtime.CompilerServices;

namespace Soenneker.Gen.Reflection.Emitters;

/// <summary>
/// Emits optimized type info classes with precomputed data and perfect hash switches
/// </summary>
internal static class OptimizedTypeInfoEmitter
{
    private static ulong _nextTypeId = 1;
    private static ulong _nextFieldId = 1;
    private static ulong _nextPropertyId = 1;
    private static ulong _nextMethodId = 1;

    /// <summary>
    /// Emits an optimized type info class for a specific type symbol
    /// </summary>
    public static void EmitOptimizedTypeInfoGenFile(SourceProductionContext context, ITypeSymbol typeSymbol)
    {
        try
        {
            var sb = new StringBuilder();
            var fileName = $"{Emitter.SanitizeTypeName(typeSymbol.ToDisplayString())}TypeInfoGen.g.cs";

            // Trace generated type for debugging
            context.ReportDiagnostic(Diagnostic.Create(new DiagnosticDescriptor("SGR101", "Generating Optimized TypeInfoGen", $"Generating optimized TypeInfoGen for {typeSymbol.ToDisplayString()}", "GetTypeGen", DiagnosticSeverity.Info, true), Location.None));

            sb.AppendLine("// <auto-generated />");
            sb.AppendLine("using System;");
            sb.AppendLine("using System.Collections.Generic;");
            sb.AppendLine("using System.Runtime.CompilerServices;");
            sb.AppendLine("using Soenneker.Gen.Reflection.Registries;");
            sb.AppendLine();

            sb.AppendLine("namespace Soenneker.Gen.Reflection");
            sb.AppendLine("{");
            sb.AppendLine();

            try
            {
                EmitOptimizedTypeInfoGenClass(sb, typeSymbol);
            }
            catch (Exception ex)
            {
                context.ReportDiagnostic(Diagnostic.Create(
                    new DiagnosticDescriptor("SGR011", "Optimized TypeInfoGen Class Generation Error", 
                        $"Error generating optimized TypeInfoGen class for {typeSymbol.ToDisplayString()}: {ex}", 
                        "GetTypeGen", DiagnosticSeverity.Error, true), Location.None));
                throw;
            }

            sb.AppendLine("}");
            Emitter.AddSource(context, fileName, sb);
        }
        catch (Exception ex)
        {
            context.ReportDiagnostic(Diagnostic.Create(
                new DiagnosticDescriptor("SGR010", "Optimized TypeInfoGen File Generation Error", 
                    $"Error generating optimized TypeInfoGen file for {typeSymbol.ToDisplayString()}: {ex}", 
                    "GetTypeGen", DiagnosticSeverity.Error, true), Location.None));
        }
    }

    private static void EmitOptimizedTypeInfoGenClass(StringBuilder sb, ITypeSymbol typeSymbol)
    {
        string typeName = typeSymbol.ToDisplayString();
        string className = Emitter.SanitizeTypeName(typeName);
        ulong typeId = _nextTypeId++;

        sb.AppendLine($"/// <summary>");
        sb.AppendLine($"/// Optimized type information for {typeName}");
        sb.AppendLine($"/// </summary>");
        // Removed SkipLocalsInit to avoid requiring unsafe context in some consumers
        sb.AppendLine($"public static partial class {className}TypeInfoGen");
        sb.AppendLine($"{{");
        
        // Generate static readonly fields for all data
        sb.AppendLine($"    private static readonly ulong _typeId = {typeId}UL;");
        sb.AppendLine($"    private static readonly string _name = \"{Emitter.GetTypeName(typeSymbol)}\";");
        sb.AppendLine($"    private static readonly string _fullName = \"{typeSymbol.ToDisplayString()}\";");
        sb.AppendLine($"    private static readonly string _assemblyQualifiedName = \"{typeSymbol.ToDisplayString()}, {typeSymbol.ContainingAssembly?.Name ?? "Unknown"}\";");
        sb.AppendLine($"    private static readonly bool _isValueType = {typeSymbol.IsValueType.ToString().ToLower()};");
        sb.AppendLine($"    private static readonly bool _isReferenceType = {typeSymbol.IsReferenceType.ToString().ToLower()};");
        sb.AppendLine($"    private static readonly bool _isGenericType = {(typeSymbol is INamedTypeSymbol namedType && namedType.IsGenericType).ToString().ToLower()};");
        sb.AppendLine($"    private static readonly bool _isNullable = {Emitter.IsNullableType(typeSymbol).ToString().ToLower()};");
        sb.AppendLine();

        // Generate field information with IDs
        EmitOptimizedFieldInformation(sb, typeSymbol, typeId);
        
        // Generate property information with IDs
        EmitOptimizedPropertyInformation(sb, typeSymbol, typeId);
        
        // Generate method information with IDs
        EmitOptimizedMethodInformation(sb, typeSymbol, typeId);

        // Generate the main TypeInfoGen instance
        sb.AppendLine($"    /// <summary>");
        sb.AppendLine($"    /// Precomputed TypeInfoGen instance for {typeName}");
        sb.AppendLine($"    /// </summary>");
        sb.AppendLine($"    public static readonly TypeInfoGen Instance = new TypeInfoGen(");
        sb.AppendLine($"        _typeId, _name, _fullName, _assemblyQualifiedName,");
        sb.AppendLine($"        _isValueType, _isReferenceType, _isGenericType, _isNullable,");
        sb.AppendLine($"        _fieldIds, _propertyIds, _methodIds,");
        sb.AppendLine($"        {Emitter.GetUnderlyingTypeId(typeSymbol)}, {Emitter.GetGenericTypeArgumentIds(typeSymbol)});");
        sb.AppendLine();

        // Generate static constructor to register everything
        sb.AppendLine($"    static {className}TypeInfoGen()");
        sb.AppendLine($"    {{");
        sb.AppendLine($"        // Register type");
        sb.AppendLine($"        TypeRegistry.Register(_typeId, Instance, _name);");
        sb.AppendLine($"        ");
        sb.AppendLine($"        // Register fields");
        EmitFieldRegistrations(sb, typeSymbol, typeId);
        sb.AppendLine($"        ");
        sb.AppendLine($"        // Register properties");
        EmitPropertyRegistrations(sb, typeSymbol, typeId);
        sb.AppendLine($"        ");
        sb.AppendLine($"        // Register methods");
        EmitMethodRegistrations(sb, typeSymbol, typeId);
        sb.AppendLine($"    }}");
        sb.AppendLine($"}}");
        sb.AppendLine();
    }

    private static void EmitOptimizedFieldInformation(StringBuilder sb, ITypeSymbol typeSymbol, ulong typeId)
    {
        IFieldSymbol[] allInstanceFields = typeSymbol.GetMembers().OfType<IFieldSymbol>()
            .Where(f => !f.IsImplicitlyDeclared && f.AssociatedSymbol == null && !f.IsStatic)
            .ToArray();

        if (allInstanceFields.Length == 0)
        {
            sb.AppendLine($"    private static readonly ulong[] _fieldIds = Array.Empty<ulong>();");
            sb.AppendLine();
            return;
        }

        sb.AppendLine($"    private static readonly ulong[] _fieldIds = new ulong[]");
        sb.AppendLine($"    {{");
        
        foreach (IFieldSymbol field in allInstanceFields)
        {
            sb.AppendLine($"        {_nextFieldId}UL,");
            _nextFieldId++;
        }
        
        sb.AppendLine($"    }};");
        sb.AppendLine();
    }

    private static void EmitOptimizedPropertyInformation(StringBuilder sb, ITypeSymbol typeSymbol, ulong typeId)
    {
        IPropertySymbol[] properties = typeSymbol.GetMembers().OfType<IPropertySymbol>()
            .Where(p => !p.IsIndexer && p.Parameters.Length == 0 && p.ExplicitInterfaceImplementations.Length == 0 && p.CanBeReferencedByName && !p.IsStatic)
            .ToArray();

        if (properties.Length == 0)
        {
            sb.AppendLine($"    private static readonly ulong[] _propertyIds = Array.Empty<ulong>();");
            sb.AppendLine();
            return;
        }

        sb.AppendLine($"    private static readonly ulong[] _propertyIds = new ulong[]");
        sb.AppendLine($"    {{");
        
        foreach (IPropertySymbol property in properties)
        {
            sb.AppendLine($"        {_nextPropertyId}UL,");
            _nextPropertyId++;
        }
        
        sb.AppendLine($"    }};");
        sb.AppendLine();
    }

    private static void EmitOptimizedMethodInformation(StringBuilder sb, ITypeSymbol typeSymbol, ulong typeId)
    {
        IMethodSymbol[] methods = typeSymbol.GetMembers().OfType<IMethodSymbol>().Where(m => m.MethodKind == MethodKind.Ordinary).ToArray();

        if (methods.Length == 0)
        {
            sb.AppendLine($"    private static readonly ulong[] _methodIds = Array.Empty<ulong>();");
            sb.AppendLine();
            return;
        }

        sb.AppendLine($"    private static readonly ulong[] _methodIds = new ulong[]");
        sb.AppendLine($"    {{");
        
        foreach (IMethodSymbol method in methods)
        {
            sb.AppendLine($"        {_nextMethodId}UL,");
            _nextMethodId++;
        }
        
        sb.AppendLine($"    }};");
        sb.AppendLine();
    }

    private static void EmitFieldRegistrations(StringBuilder sb, ITypeSymbol typeSymbol, ulong typeId)
    {
        IFieldSymbol[] allInstanceFields = typeSymbol.GetMembers().OfType<IFieldSymbol>()
            .Where(f => !f.IsImplicitlyDeclared && f.AssociatedSymbol == null && !f.IsStatic)
            .ToArray();

        ulong fieldId = _nextFieldId - (ulong)allInstanceFields.Length;
        foreach (IFieldSymbol field in allInstanceFields)
        {
            string fieldType = Emitter.GetTypeName(field.Type);
            ulong fieldTypeId = GetOrCreateTypeId(field.Type);
            
            if (field.DeclaredAccessibility == Accessibility.Public)
            {
                string declaringType = Emitter.FormatFullyQualified(typeSymbol);
                string castType = Emitter.FormatFullyQualified(field.Type);
                var getter = $"new Func<object, object>(obj => (({declaringType})obj).{field.Name})";
                string setter = field.IsReadOnly ? "null" : $"new Action<object, object>((obj, value) => (({declaringType})obj).{field.Name} = ({castType})value)";
                sb.AppendLine($"        FieldRegistry.Register({fieldId}UL, new FieldInfoGen({fieldId}UL, \"{field.Name}\", {fieldTypeId}UL, {field.IsReadOnly.ToString().ToLower()}, {getter}, {setter}), _typeId);");
            }
            else
            {
                sb.AppendLine($"        FieldRegistry.Register({fieldId}UL, new FieldInfoGen({fieldId}UL, \"{field.Name}\", {fieldTypeId}UL, {field.IsReadOnly.ToString().ToLower()}), _typeId);");
            }
            fieldId++;
        }
    }

    private static void EmitPropertyRegistrations(StringBuilder sb, ITypeSymbol typeSymbol, ulong typeId)
    {
        IPropertySymbol[] properties = typeSymbol.GetMembers().OfType<IPropertySymbol>()
            .Where(p => !p.IsIndexer && p.Parameters.Length == 0 && p.ExplicitInterfaceImplementations.Length == 0 && p.CanBeReferencedByName && !p.IsStatic)
            .ToArray();

        ulong propertyId = _nextPropertyId - (ulong)properties.Length;
        foreach (IPropertySymbol property in properties)
        {
            string declaringType = Emitter.FormatFullyQualified(typeSymbol);
            string propTypeName = Emitter.GetTypeName(property.Type);
            ulong propertyTypeId = GetOrCreateTypeId(property.Type);
            string castType = Emitter.FormatFullyQualified(property.Type);
            string getter = property.GetMethod != null ? $"new Func<object, object>(obj => (({declaringType})obj).{property.Name})" : "null";
            string setter = property.SetMethod != null ? $"new Action<object, object>((obj, value) => (({declaringType})obj).{property.Name} = ({castType})value)" : "null";
            
            sb.AppendLine($"        PropertyRegistry.Register({propertyId}UL, new PropertyInfoGen({propertyId}UL, \"{property.Name}\", {propertyTypeId}UL, {(property.GetMethod != null).ToString().ToLower()}, {(property.SetMethod != null).ToString().ToLower()}, {getter}, {setter}), _typeId);");
            propertyId++;
        }
    }

    private static void EmitMethodRegistrations(StringBuilder sb, ITypeSymbol typeSymbol, ulong typeId)
    {
        IMethodSymbol[] methods = typeSymbol.GetMembers().OfType<IMethodSymbol>().Where(m => m.MethodKind == MethodKind.Ordinary).ToArray();

        ulong methodId = _nextMethodId - (ulong)methods.Length;
        foreach (IMethodSymbol method in methods)
        {
            ulong returnTypeId = GetOrCreateTypeId(method.ReturnType);
            var parameterTypeIds = method.Parameters.Select(p => GetOrCreateTypeId(p.Type)).ToArray();
            string parameterIdsArray = parameterTypeIds.Length == 0 ? "Array.Empty<ulong>()" : $"new ulong[] {{ {string.Join(", ", parameterTypeIds)} }}";
            
            sb.AppendLine($"        MethodRegistry.Register({methodId}UL, new MethodInfoGen({methodId}UL, \"{method.Name}\", {returnTypeId}UL, {method.IsStatic.ToString().ToLower()}, {parameterIdsArray}), _typeId);");
            methodId++;
        }
    }

    private static ulong GetOrCreateTypeId(ITypeSymbol typeSymbol)
    {
        // For now, return a simple hash-based ID
        // In a real implementation, you'd want to track and reuse IDs for the same types
        return (ulong)typeSymbol.GetHashCode();
    }
}
